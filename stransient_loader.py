"""
Provides utilities to load STRANSIENT export CSV files generated by PyPSA-DE
and translate them back into an executable Pandapower network.
"""

from pathlib import Path

import pandas as pd

try:
    import pandapower as pp
except (
    ImportError
) as exc:  # pragma: no cover - fallback for environments without pandapower
    raise ImportError(
        "pandapower is required to build a STRANSIENT grid but is not installed."
    ) from exc


def _safe_per_km(value: float, length_km: float) -> float:
    return float(value) / max(float(length_km), 1e-6)


def build_net_from_stransient(
    folder: Path,
    slack_bus_id: str | None = None,
    vm_pu: float = 1.02,
) -> pp.pandapowerNet:
    """
    Translate exported STRANSIENT CSVs into a runnable pandapower network.

    This function expects four specific CSV exports from the export_stransient script:
        - stransient_bus.csv
        - stransient_branch.csv
        - stransient_gen.csv
        - stransient_load.csv

    Parameters
    ----------
    folder : Path
        Directory where the STRANSIENT CSV files are located.
    slack_bus_id : str | None, optional
        ID of the bus to assign as the external grid (slack node). If None, the
        first bus found in the dataset is used. Default is None.
    vm_pu : float, optional
        Voltage magnitude setpoint (in p.u.) for the slack node. Default is 1.02.

    Returns
    -------
    pp.pandapowerNet
        A fully constructed Pandapower network.
    """
    folder = Path(folder)
    if not folder.exists():
        raise FileNotFoundError(f"STRANSIENT folder not found: {folder}")

    # Required files
    files = {
        "buses": folder / "stransient_bus.csv",
        "branches": folder / "stransient_branch.csv",
        "generators": folder / "stransient_gen.csv",
        "loads": folder / "stransient_load.csv",
    }

    for name, path in files.items():
        if not path.exists():
            raise FileNotFoundError(f"Missing {name} export at {path}")

    bus_df = pd.read_csv(files["buses"])
    line_df = pd.read_csv(files["branches"])
    gen_df = pd.read_csv(files["generators"])
    load_df = pd.read_csv(files["loads"])

    net = pp.create_empty_network()
    bus_map: dict[str, int] = {}
    for _, row in bus_df.iterrows():
        bus_id = row["bus_id"]
        bus_map[bus_id] = pp.create_bus(net, vn_kv=row["vn_kv"], name=bus_id)

    slack_bus_id = slack_bus_id or (bus_df["bus_id"].iloc[0] if len(bus_df) else None)
    if slack_bus_id and slack_bus_id in bus_map:
        pp.create_ext_grid(
            net, bus=bus_map[slack_bus_id], vm_pu=vm_pu, name="STRANSIENT slack"
        )
    elif bus_map:
        first_bus = next(iter(bus_map.values()))
        pp.create_ext_grid(
            net, bus=first_bus, vm_pu=vm_pu, name="STRANSIENT slack (default)"
        )

    for _, row in gen_df.iterrows():
        bus_name = row["bus"]
        if bus_name not in bus_map:
            continue
        pp.create_sgen(
            net,
            bus=bus_map[bus_name],
            p_mw=row.get("p_max_mw", 0.0),
            q_mvar=row.get("q_max_mvar", 0.0),
            name=row.get("gen_id", f"sgen-{bus_name}"),
        )

    for _, row in load_df.iterrows():
        bus_name = row["bus"]
        if bus_name not in bus_map:
            continue
        pp.create_load(
            net,
            bus=bus_map[bus_name],
            p_mw=row.get("p_mw", 0.0),
            q_mvar=row.get("q_mvar", 0.0),
            name=row.get("load_id", f"load-{bus_name}"),
        )

    for _, row in line_df.iterrows():
        bus0 = row["bus0"]
        bus1 = row["bus1"]
        if bus0 not in bus_map or bus1 not in bus_map:
            continue
        length_km = float(row.get("length", 1.0))
        pp.create_line_from_parameters(
            net,
            bus_map[bus0],
            bus_map[bus1],
            length_km=length_km,
            r_ohm_per_km=_safe_per_km(row.get("r", 0.0), length_km),
            x_ohm_per_km=_safe_per_km(row.get("x", 0.0), length_km),
            c_nf_per_km=float(row.get("c_nf_per_km", 0.0)),
            max_i_ka=float(row.get("i_nom", 1.0)),
            name=row.get("branch_id", f"branch-{bus0}-{bus1}"),
        )

    return net
